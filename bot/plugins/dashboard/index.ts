/**
 * Dashboard Plugin â€” Next.js web dashboard served from its own port.
 *
 * Boots a Next.js app on DASHBOARD_PORT (default 3000).
 * The dashboard contacts the bot API at API_PORT with INTERNAL_API_KEY.
 */

import * as http from "http";
import * as fs from "fs";
import * as path from "path";
import type { PluginContext, PluginAPI, PluginLogger } from "../../src/types/Plugin.js";
import type { LibAPI } from "../lib/index.js";

// Register Mongoose models
import "./models/DashboardPermission.js";
import "./models/DashboardSettings.js";

export interface DashboardPluginAPI extends PluginAPI {
  version: string;
  /** Port the dashboard is listening on */
  port: number;
  /** Available plugin features (populated from optional deps) */
  features: string[];
}

let server: http.Server | null = null;

export async function onLoad(context: PluginContext): Promise<DashboardPluginAPI> {
  const { logger, pluginPath, dependencies, getEnv } = context;

  const lib = dependencies.get("lib") as LibAPI | undefined;
  if (!lib) throw new Error("dashboard requires lib plugin");

  const port = parseInt(getEnv("DASHBOARD_PORT") || "3000", 10);
  const isDev = process.env.NODE_ENV !== "production";

  // Determine which optional plugin features are available
  const optionalPlugins = ["minecraft", "modmail", "tickets", "suggestions", "tags", "logging", "welcome", "tempvc", "reminders", "vc-transcription"];
  const features = optionalPlugins.filter((p) => dependencies.has(p));
  logger.info(`Available dashboard features: ${features.length > 0 ? features.join(", ") : "none"}`);

  // â”€â”€ Write .env.local so Next.js can see the bot's env vars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Next.js loads .env from its own `dir`, not the bot root. Rather than
  // hardcoding var names in next.config.mjs we read the manifest's
  // requiredEnv + optionalEnv and forward every defined value.
  const appDir = path.join(pluginPath, "app");
  const manifest = JSON.parse(fs.readFileSync(path.join(pluginPath, "manifest.json"), "utf-8"));
  const envKeys: string[] = [...(manifest.requiredEnv ?? []), ...(manifest.optionalEnv ?? [])];

  // Also forward vars that Next.js / NextAuth look for implicitly
  const implicitKeys = ["AUTH_SECRET", "NEXTAUTH_URL", "NODE_ENV", "API_PORT"];
  const allKeys = [...new Set([...envKeys, ...implicitKeys])];

  const lines: string[] = ["# Auto-generated by dashboard plugin â€” do not edit manually", `# Generated at ${new Date().toISOString()}`];

  for (const key of allKeys) {
    let value = process.env[key];

    // Map NEXTAUTH_SECRET â†’ AUTH_SECRET (NextAuth v5 expects AUTH_SECRET)
    if (key === "AUTH_SECRET" && !value) value = process.env.NEXTAUTH_SECRET;

    // Auto-derive NEXTAUTH_URL from DASHBOARD_PORT if not explicitly set
    if (key === "NEXTAUTH_URL" && !value) {
      value = `http://localhost:${process.env.DASHBOARD_PORT || "3000"}`;
    }

    if (value !== undefined) lines.push(`${key}=${value}`);
  }

  const envLocalPath = path.join(appDir, ".env.local");
  fs.writeFileSync(envLocalPath, lines.join("\n") + "\n", { encoding: "utf-8", mode: 0o600 });
  logger.debug(`Wrote ${allKeys.length} env vars to .env.local (mode 0600)`);

  // Boot Next.js

  // Dynamic import so Next.js isn't required at module parse time
  const next = (await import("next")).default;

  const nextApp = next({
    dev: isDev,
    dir: appDir,
    quiet: !isDev,
  });

  const handle = nextApp.getRequestHandler();

  logger.info(`Preparing Next.js (${isDev ? "development" : "production"})...`);
  await nextApp.prepare();

  // Create HTTP server
  server = http.createServer((req, res) => {
    handle(req, res);
  });

  await new Promise<void>((resolve, reject) => {
    server!.on("error", reject);
    server!.listen(port, () => {
      logger.info(`âœ… Dashboard running on http://localhost:${port}`);
      resolve();
    });
  });

  return {
    version: "1.0.0",
    port,
    features,
  };
}

export async function onDisable(logger: PluginLogger): Promise<void> {
  if (server) {
    await new Promise<void>((resolve, reject) => {
      server!.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    });
    server = null;
  }

  // Clean up .env.local to avoid leaving secrets on disk
  try {
    const appDir = path.join(__dirname, "app");
    const envLocalPath = path.join(appDir, ".env.local");
    if (fs.existsSync(envLocalPath)) {
      fs.unlinkSync(envLocalPath);
      logger.debug("Cleaned up .env.local");
    }
  } catch {
    // Best-effort cleanup
  }

  logger.info("ðŸ›‘ Dashboard plugin unloaded");
}
