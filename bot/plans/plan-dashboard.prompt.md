## Plan: Discord-Style Guild Dashboard Permissions

A three-state (deny / inherit / allow) permissions system mirroring Discord's channel permissions. Permissions are grouped by **feature category** with **granular per-action control**. Action-level overrides always take precedence over category-level — a deny on a category with an allow on a specific action grants that action; an allow on a category with a deny on a specific action blocks that action. Multi-role conflicts use deny-wins (matching Discord). Guild owners always have full access; Discord Administrators get full access unless explicitly restricted.

### Steps

1. **Create `DashboardPermission` and `DashboardSettings` Mongoose models** in bot/plugins/dashboard/models/. `DashboardPermission`: `guildId` + `discordRoleId` (compound unique), `roleName`, `overrides: Map<string, "allow" | "deny">` — keys are category-level (`minecraft`) or action-level (`minecraft.manage_config`). `DashboardSettings`: `guildId` (unique), `hideDeniedFeatures: boolean` (default `false` — show locked features; when `true`, hide inaccessible sidebar items entirely). Only owners/admins with `dashboard.manage_permissions` can toggle this.

2. **Define a static permission registry** in bot/plugins/dashboard/app/lib/permissionDefs.ts. Array of categories each with `key`, `label`, `description`, and `actions[]` (`key`, `label`, `description`). Categories: `dashboard` (`manage_permissions`, `manage_settings`), `minecraft` (`view_players`, `manage_players`, `manage_config`, `approve_whitelist`, `manage_status`, `use_rcon`), `tickets` (`view_tickets`, `manage_tickets`, `manage_categories`, `manage_openers`), `modmail` (`view_conversations`, `manage_config`), `suggestions` (`view_suggestions`, `manage_suggestions`, `manage_config`, `manage_categories`), `tags` (`view_tags`, `manage_tags`), `logging` (`view_config`, `manage_config`), `welcome` (`view_config`, `manage_config`), `tempvc` (`view_config`, `manage_config`), `reminders` (`view_reminders`, `manage_reminders`).

3. **Define a static route-to-action map** in bot/plugins/dashboard/app/lib/routePermissions.ts. A `Record<string, string>` mapping `"METHOD /path/pattern"` → action key. E.g. `"GET /minecraft/players"` → `"minecraft.view_players"`, `"PUT /minecraft/config"` → `"minecraft.manage_config"`, `"POST /minecraft/players/*/approve"` → `"minecraft.approve_whitelist"`, `"GET /dashboard-permissions"` → `"dashboard.manage_permissions"`. A `resolveRouteAction(method, pathSegments)` function matches the request against patterns and returns the required action key.

4. **Add a bot-side `/guilds/:guildId/members/:userId` endpoint** in ApiManager.ts. Returns `{ roleIds: string[], isOwner: boolean, isAdministrator: boolean }`. Fetched from Discord guild cache. Used by the proxy on every request for fresh role data.

5. **Add bot-side CRUD routes for permissions and settings** — `/guilds/:guildId/dashboard-permissions` (`GET /`, `PUT /:roleId`, `DELETE /:roleId`) and `/guilds/:guildId/dashboard-settings` (`GET /`, `PUT /`) mounted in ApiManager.ts. Themselves gated by the proxy's permission check on `dashboard.manage_permissions` / `dashboard.manage_settings`.

6. **Create a `resolvePermissions` helper** in bot/plugins/dashboard/app/lib/permissions.ts. Resolution logic: **(a)** Guild owner → allow everything, always, unconditionally. **(b)** Collect all `overrides` maps from roles the user has. **(c)** For each action key in the registry: first check if any role has an explicit action-level entry — if so, deny-wins across roles at that level; if no action-level entry exists, fall back to category-level entries and apply deny-wins there; if neither exists, inherit. **(d)** Discord Administrators: before step (c), default every action to `allow`, then apply overrides on top — so Administrators have full access unless explicitly denied. Returns a `{ has(actionKey): boolean, getAll(): Record<string, boolean>, hasAnyInCategory(categoryKey): boolean }` object.

7. **Gate the API proxy** in [bot/plugins/dashboard/app/app/api/guilds/[guildId]/[...path]/route.ts](bot/plugins/dashboard/app/app/api/guilds/%5BguildId%5D/%5B...path%5D/route.ts). On each request: resolve the route to an action key via the static map, fetch member data (`/members/:userId`), fetch guild permission overrides + settings (cache both ~30s), run `resolvePermissions`, return 403 if denied. Pass `X-User-Permissions` header downstream so pages can conditionally render edit controls.

8. **Build the Permissions settings page** at [bot/plugins/dashboard/app/app/[guildId]/settings/](bot/plugins/dashboard/app/app/%5BguildId%5D/settings/). Two sections: **(a)** General settings — `hideDeniedFeatures` toggle (hide vs show-locked sidebar items). **(b)** Role permissions — left panel: role list (add via `Combobox`, click to select); right panel: Discord-style permission list grouped by category. Each category header has its own three-state slider (✕ / ─ / ✓) and an expand/collapse. Each action row shows name + description on the left, three-state slider on the right. Category slider shows mixed state (─) when its actions differ. Only accessible to users with `dashboard.manage_permissions`.

9. **Update sidebar rendering** in [bot/plugins/dashboard/app/app/[guildId]/GuildLayoutShell.tsx](bot/plugins/dashboard/app/app/%5BguildId%5D/GuildLayoutShell.tsx). Fetch the user's resolved permissions + `hideDeniedFeatures` setting on mount. If `hideDeniedFeatures` is `true`, filter out nav items where the user has zero allowed actions in that category. If `false`, show all items but render inaccessible ones grayed out with a lock icon; clicking navigates to a "no access" placeholder page.

### Further Considerations

1. **Permission caching strategy** — The proxy caches member roles + guild overrides for ~30s server-side. A **"Refresh Permissions"** button is available on the settings page header for admins to force-reload after role changes. ✅ Implemented.

2. **Audit logging** — Permission changes (upsert, delete) and settings changes are logged to the guild's audit logging channel if the logging plugin is enabled with the `audit` category configured. A new `AUDIT` logging category with `dashboard_permissions` and `dashboard_settings` subcategories was added. ✅ Implemented.
